{"meta":{"title":"CODE is POETRY","subtitle":null,"description":"Nothing is pure. But solitude.","author":"Wayne","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-02-27T10:42:24.000Z","updated":"2017-02-27T11:01:26.337Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我的更多 GitHub 知乎 豆瓣"},{"title":"categories","date":"2017-02-27T10:39:30.000Z","updated":"2017-02-27T10:40:02.873Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-27T10:26:16.000Z","updated":"2017-02-27T10:34:51.492Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"高斯模糊","date":"2017-03-29T03:50:54.167Z","updated":"2017-03-29T13:39:58.106Z","comments":true,"path":"2017/03/29/高斯模糊/","link":"","permalink":"http://yoursite.com/2017/03/29/高斯模糊/","excerpt":"","text":"高斯模糊原理对于一张图片, 如果每个像素点都和与它临近的像素点相似, 那么这张图片看起来就比较的模糊. 自然地, 我们可以让每个像素点的值等于其周围像素点值的平均值, 从而达到模糊图片的效果. 如何取平均值我们将周围的点定义为: 在水平, 竖直, 主对角线, 副对角线四个方向上, 每个方向关于像素点对称的两侧各取的r个点. r就称为模糊半径.显然r越大, 模糊效果就越明显.上面的图片分别是原图, 模糊半径为1, 模糊半径为3的效果图. 由于像素点与距离其较近的点更为相似, 所以在去平均值的时候, 应该采用加权平均. 对于二维的图像, 我们可以采用二维的正态分布函数: 边界点的处理按照上面的方法, 在边界处的点会缺失部分周围的点. 我们可以用其关于边界点对称处的点代替. 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from matplotlib import imagefrom math import pi, expimport numpy as npdef Gauss(x, y): # 标准二维正态分布 return 1 / (2 * pi) * exp(-(x ** 2 + y ** 2) / 2)def weight(): # 返回归一化的权值矩阵 w = np.empty((c, c)) for axis0 in range(c): for axis1 in range(c): w[axis0, axis1] = Gauss(axis1 - radius, radius - axis0) return w / np.sum(w)def adjust(val, subs): if val &lt; 0: return -val elif val &gt;= subs: return 2 * subs - val - 2 return valdef processBoundary(axis0, axis1): r, g, b = np.empty((3, c, c)) for y in range(-radius, radius + 1): py = adjust(axis0 + y, height) iy = y + radius for x in range(-radius, radius + 1): px = adjust(axis1 + x, width) ix = x + radius r[iy][ix] = im[py][px][0] g[iy][ix] = im[py][px][1] b[iy][ix] = im[py][px][2] blurredIm[axis0, axis1] = np.sum(r * w), np.sum(g * w), np.sum(b * w)def gaussianBlur(): for axis0 in range(height): for axis1 in range(width): l0, u0 = axis0 - radius, axis0 + radius + 1 l1, u1 = axis1 - radius, axis1 + radius + 1 # 边界点的判断 if l0 &lt; 0 or l1 &lt; 0 or u0 &gt; height or u1 &gt; width: processBoundary(axis0, axis1) continue area = im[l0:u0, l1:u1] r, g, b = area[:, :, 0], area[:, :, 1], area[:, :, 2] blurredIm[axis0, axis1] = np.sum( r * w), np.sum(g * w), np.sum(b * w) image.imsave('&#123;0&#125;-&#123;1&#125;.jpg'.format(filename, radius), blurredIm)if __name__ == '__main__': filename = \"gakki.jpg\" im = image.imread(filename) height, width = im.shape[0:2] radius = 5 c = 2 * radius + 1 # 正方形邻域的边长 w = weight() blurredIm = np.empty(im.shape, dtype=np.uint8) gaussianBlur()","categories":[],"tags":[]},{"title":"Hexo博客笔记","slug":"Hexo博客笔记","date":"2017-02-27T09:07:09.000Z","updated":"2017-02-27T11:24:09.935Z","comments":true,"path":"2017/02/27/Hexo博客笔记/","link":"","permalink":"http://yoursite.com/2017/02/27/Hexo博客笔记/","excerpt":"记录踩过的坑和一些感悟 大道至简在博客配置完成后, 试过不下10个主题. 作为一个肤浅的人, 自然喜欢折腾这些华丽的外在. 配置主题耗费了大量时间. 从logo到背景图, 到文章配图, 不可谓少花时间. 虽说不指望多少人回访问博客, 但至少自己看着也是赏心悦目. 但折腾几天就觉得索然无趣. 自己的初衷本是利用博客督促自己写作, 记录遇到的问题, 总结做过的事情. 就像一本允许外人翻看的日记. 最后, 我放弃了之前所有的主题, 选择了一个颜值和简洁兼备的Hiker主题. 新鲜感总会过去.","text":"记录踩过的坑和一些感悟 大道至简在博客配置完成后, 试过不下10个主题. 作为一个肤浅的人, 自然喜欢折腾这些华丽的外在. 配置主题耗费了大量时间. 从logo到背景图, 到文章配图, 不可谓少花时间. 虽说不指望多少人回访问博客, 但至少自己看着也是赏心悦目. 但折腾几天就觉得索然无趣. 自己的初衷本是利用博客督促自己写作, 记录遇到的问题, 总结做过的事情. 就像一本允许外人翻看的日记. 最后, 我放弃了之前所有的主题, 选择了一个颜值和简洁兼备的Hiker主题. 新鲜感总会过去. 文章预览配置好Hiker主题后发现, 在HOME页的文章列表中, 文章内容全部被显示了. 不仅不方便, 而且奇丑无比.而在主题配置文件中, 并没有显示预览长度的选项. 解决方法: 在你希望显示的内容的下边添加一行&lt;!-- more --&gt;, 这之后的内容就不会显示在预览上了. npm更换安装源npm的源在国外,由于众所周知的原因,国内下载速度很慢.经常会导致安装失败 可以参考:npm换源 学习git早就知道git的强大和重要了, 但由于没有实际的需要, 没有认真学习过. 由于使用hexo需要安装git, 而且我也是配合GitHub Pages来搭建博客, 所以干脆将git学习了一遍. 参考: Git教程 技术的学习需要需求的驱动. 有了学习的目的, 学起来才不盲目, 不累. 感谢很幸运, 遇到的问题都能在网上找到解决方法. 我想我能遇到的绝大部分问题, 都早有人遇到过了. 他们中的一些选择把自己踩过的坑分享出来, 方便了我这种后来者. 无论写的好与差, 无疑都是值得感谢的. Ideas worth spreading.","categories":[],"tags":[{"name":"notes","slug":"notes","permalink":"http://yoursite.com/tags/notes/"}]},{"title":"MarkDown Syntax","slug":"MarkDown Syntax","date":"2017-02-26T13:50:12.000Z","updated":"2017-02-27T09:55:05.414Z","comments":true,"path":"2017/02/26/MarkDown Syntax/","link":"","permalink":"http://yoursite.com/2017/02/26/MarkDown Syntax/","excerpt":"前言为什么使用markdown 用markdown写成的文件是纯文本文件, 任何Text Editor都能打开. 语法简单, 只要10分钟的学习就可以开始写作. 轻松转换成pdf, html的文件格式 被广泛使用, 这是最客观的原因. 比起用word写作, markdown减少了手在键盘和鼠标间的切换, 让你更专注写作. 推荐markdown编辑器(windows) MarkDownEditor MarkDownPad 本文由MarkdownEditor撰写. 段落段落的前后应该至少有一个空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）. 值得一提的是, 没必要在段首用空格或制表符来缩进. 一方面段落间的空白已足够区分两个段落, 另一方面markdown也不支持.","text":"前言为什么使用markdown 用markdown写成的文件是纯文本文件, 任何Text Editor都能打开. 语法简单, 只要10分钟的学习就可以开始写作. 轻松转换成pdf, html的文件格式 被广泛使用, 这是最客观的原因. 比起用word写作, markdown减少了手在键盘和鼠标间的切换, 让你更专注写作. 推荐markdown编辑器(windows) MarkDownEditor MarkDownPad 本文由MarkdownEditor撰写. 段落段落的前后应该至少有一个空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）. 值得一提的是, 没必要在段首用空格或制表符来缩进. 一方面段落间的空白已足够区分两个段落, 另一方面markdown也不支持. 标题在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶, 像这样:12# H1## H2 引用只需在段落前加上’&gt;’, 像这样:123&gt; Named tuples assign meaning to each position in a tuple and allow for more readable,&gt; self-documenting code.They can be used wherever regular tuples are used, and they add the&gt; ability to access fields by name instead of position index. 效果: Named tuples assign meaning to each position in a tuple and allow for more readable,self-documenting code.They can be used wherever regular tuples are used, and they add theability to access fields by name instead of position index. 值得一提的是, 在引用中可以使用其他markdown的语法. 另外, 引用也可以是嵌套的. 列表无序列表无序列表使用星号(*)、加号(-)或是减号(-)作为列表标记 个人推荐减号, 毕竟可以少按一个shift. 像这样:123- python- java- lisp 效果: python java lisp 有序列表有序列表则使用数字接着一个英文句点, 句点后要有一个空格：1231. 中国2. 美国3. 英国 效果: 中国 美国 英国 值得注意的是, 你不必在意前面数字的正确性. 是123, 还是396, 都无所谓. 但是为什么要这样呢, 不说别的, 看着也是不舒服的. 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符 当然了, 如果每行都要缩进未免麻烦, markdown也允许你这样:1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 效果: This is a list item with two paragraphs. This is the second paragraph in the list item. You’reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit. Another item in the same list. 代码123456789可以这样, 用3个 `, 并加上语言名称: ```c #include &lt;stdio.h&gt; int main(int argc, char const *argv[]) &#123; return 0; &#125; 123456789效果:```c#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; return 0;&#125; 或者12345678每行前缩进四个空格或者一个制表符: #include &lt;stdio.h&gt; int main(int argc, char const *argv[]) &#123; return 0; &#125; 效果: #include &lt;stdio.h&gt; int main(int argc, char const *argv[]) { return 0; } 有时候, 我们只想在行内插入很短的一段代码, 而不是另起一行, 这时候应该把什么的3个`改为一个: 输入python example.py 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格. 链接行内式像这样:1This is [an example](http://example.com/ &apos;Title&apos;) inline link. 会得到: This is an example inline link. 被方括号包围的是链接文字. 被引号包围的是,鼠标放在链接上所显示的内容(可以不写), 第一个引号前要有一个空格. 你也可以使用相对地址-如果你是要链接到同样主机的资源. 自动链接用尖括号将网址包起来即可, 链接文字一般和链接地址一样.1&lt;http://example.com/&gt; 效果: http://example.com/ 图片语法与链接类似 最前面加上一个惊叹号 方括号里面是替代图片的文字(图片不存在时显示) 小括号里面是图片地址1![](http://img.mukewang.com/57ac6d330001792d07200450-210-130.jpg) 强调*和-作为强调标记符号, 用一个*和-包围起来的就是斜体, 两个的就是粗体.","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]},{"title":"文本文件压缩(Python)","slug":"文本文件压缩(Python)","date":"2017-02-20T13:50:12.000Z","updated":"2017-02-27T10:00:22.732Z","comments":true,"path":"2017/02/20/文本文件压缩(Python)/","link":"","permalink":"http://yoursite.com/2017/02/20/文本文件压缩(Python)/","excerpt":"压缩原理对于文本文件，里面的每一个字符都是8位的ASCII字符. 比如对于’python’, 是这样存储的: 01110000 01111001 ‭01110100‬ ‭01101000‬ ‭01101111‬ 01101110‬ 我们可以为每个字符指定一个编码, 满足不同的字符编码不同, 出现频率高的字符分配到的编码短的条件.比如为’python’的6个字符分别分配0, 1, 00, 01, 10, 11的编码. 再将编码信息(0100011011)写入文件, 就达到了压缩的目的. 霍夫曼编码(Huffman Coding)霍夫曼编码-维基百科 霍夫曼编码是无损数据压缩和权编码算法. 所谓权编码, 就是根据源符号出现的概率大小分配不同长度的编码。出现概率高的符号分配短码，概率低的符号分配长码. 霍夫曼编码通过构建一颗最优二叉树(一种带权路径长度最短的二叉树)来为符号分配编码.所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度. 权值为符号出现频数.","text":"压缩原理对于文本文件，里面的每一个字符都是8位的ASCII字符. 比如对于’python’, 是这样存储的: 01110000 01111001 ‭01110100‬ ‭01101000‬ ‭01101111‬ 01101110‬ 我们可以为每个字符指定一个编码, 满足不同的字符编码不同, 出现频率高的字符分配到的编码短的条件.比如为’python’的6个字符分别分配0, 1, 00, 01, 10, 11的编码. 再将编码信息(0100011011)写入文件, 就达到了压缩的目的. 霍夫曼编码(Huffman Coding)霍夫曼编码-维基百科 霍夫曼编码是无损数据压缩和权编码算法. 所谓权编码, 就是根据源符号出现的概率大小分配不同长度的编码。出现概率高的符号分配短码，概率低的符号分配长码. 霍夫曼编码通过构建一颗最优二叉树(一种带权路径长度最短的二叉树)来为符号分配编码.所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度. 权值为符号出现频数. 代码节点类最优二叉树有两类节点：叶子节点(对应着源符号)，中间节点。 叶子节点属性：符号值，符号值出现频数，编码 中间节点属性：频数(等于两个子节点频数之和)，编码，左、右子节点 代码:12345678910111213class HuffNode(object): def __init__(self, freq, value, left_child=None, right_child=None): self.freq = freq self.value = value self.huff_code = '' if value is None: self.left_child = left_child self.right_child = right_child else: self.value = value def __lt__(self, other): return self.freq &lt; other.freq 由于中间节点没有符号值这一属性，所以若参数value为None, 表明是一个中间节点。此时一定要指定最后两个参数。 lt(self, other): lt的意思是less than, 用于实现小于比较符。意味着, 你可以直接用’&lt;’比较两个HuffNode对象。有点类似于C++的操作符重载。因为霍夫曼编码涉及到排序，所以实现了这个方法。此类方法在python中叫魔法方法，可以参考Python魔法方法指南. 建立最优二叉树我们先将所有叶子节点放入优先队列。之后，每次从队列中取出两个节点，利用这两个节点的信息创建新的节点，并将新节点放回队列。如果有n个叶子节点，即源符号有n个，则进行n-1次这样的操作。最后队列剩下一个节点，即根节点，将其返回。 1234567891011121314from queue import PriorityQueue# data是记录符号及其频数的字典def buildTree(data): pq = PriorityQueue() for key, freq in data.items(): pq.put(HuffNode(freq, key)) for i in range(len(data) - 1): left = pq.get() right = pq.get() pq.put(HuffNode(left.freq + right.freq, None, left, right)) return pq.get() 获取各个节点编码从根节点开始，进行BFS(广度优先搜索)。左, 右子节点的编码为其父节点的编码分别加上’0’, ‘1’. 123456789101112131415161718from queue import Queuedef getCode(root): q = Queue() q.put(root) code = &#123;&#125; while not q.empty(): out = q.get() if out.value is None: out.left_child.huff_code = out.huff_code + '0' out.right_child.huff_code = out.huff_code + '1' q.put(out.left_child) q.put(out.right_child) else: code[out.value] = out.huff_code return code 对文件进行压缩获取编码以二进制形式打开文件，读出来的数据是int型的，范围从0~255。代表了字符的ascii值. 统计所有数值出现的频。之后利用上面的方法构造最优二叉树和获取霍夫曼编码。 123456789101112from collections import defaultdictfin = open(inputfile, 'rb')fout = open(outputfile, 'wb')data = fin.read()freq = defaultdict(int)for each in data: freq[each] += 1root = buildTree(freq)huffman_code = getCode(root) 写入压缩文件用编码将原来的符号代替，就得到一大串01组成的字符串. 字符串的每一个’0’或’1’, 都可以看作每bit上的0或1. 想办法将字符串转换成对应的bit即可. 我们先以32为单位长度切分字符串:12whole = ''.join([huffman_code[d] for d in data])splited = re.findall('.&#123;1,32&#125;', whole) 对于每一个子串, 先将其转换成int, 再用pack函数转换成bytes, 最后将bytes写入文件.12for each in splited: fout.write(pack('I', int(each, 2))) pack(fmt, v)会将值根据fmt指定的格式将v转换成bytes对象. ‘I’表示unsigned int, 大小为32bit. 因为int是4字节的, 为了不让pack()的结果前面有很多0, 从而浪费空间. 所以我们以32为长度切分字符串. note: 首先，我们需要写入一些头部信息。包括符号的个数，每个符号对应的频数。这是解压缩必要的信息。 最后一串字符串长度不一定为32, 所以还要额外的将其长度记录下来。同样也是为了解压缩所必要的。 代码1234567891011121314151617from struct import packfrom re import findallfout.write(pack('I', len(freq)))for key, val in freq.items(): fout.write(pack('I', key)) fout.write(pack('I', val))whole = ''.join([huffman_code[d] for d in data])splited = findall('.&#123;1,32&#125;', whole)for each in splited: fout.write(pack('I', int(each, 2)))fout.write(pack('I', len(splited[-1])))fin.close()fout.close() 对文件解压缩原理 根据压缩文件的头部信息建立最优二叉树. 接着读取后面的内容, 将每字节的信息转成成字符串(也就是压缩时得到的字符串). 遍历字符串, 遇到’0’指向左子节点, 遇到’1’指向右子节点. 直到叶子节点为止, 将叶子节点的值写入解压缩文件中, 并指回根节点. note 同样的, 最后的部分要特别处理. 整个过程就是压缩逆过程，直接上代码1234567891011121314151617181920212223242526272829303132333435from struct import unpackdef decompress(src, dest): fin = open(src, 'rb') fout = open(dest, 'wb') node_num = unpack('I', fin.read(4))[0] freq = &#123;&#125; for i in range(node_num): key = unpack('I', fin.read(4))[0] val = unpack('I', fin.read(4))[0] freq[key] = val root = huffman.buildTree(freq) splited = [] while True: data = fin.read(4) if not data: break code = bin(unpack('I', data)[0])[2:].zfill(32) splited.append(code) length = int(splited.pop(), 2) splited[-1] = splited[-1][-length:] whole = ''.join(splited) cur = root for each in whole: cur = cur.left_child if each == '0' else cur.right_child if cur.value is not None: fout.write(int2byte(cur.value)) cur = root fin.close() fout.close() 完善程序命令行参数何选项1234567891011121314151617181920import osfrom argparse import ArgumentParserparser = ArgumentParser(description='compress file using huffman coding')parser.add_argument('file')parser.add_argument('-d', action='store_true', help='decompress file')parser.add_argument('-o', default='a', help='name of output file, \"a\" by default')parser.add_argument('--delete', action='store_true', help='delete the source\\ file if this option is specific')args = parser.parse_args()if(args.d): decompress(args.file, args.o)else: compress(args.file, args.o) print('before compress: &#123;0&#125; Bytes'.format(os.path.getsize(args.file))) print('after compress: &#123;0&#125; Bytes'.format(os.path.getsize(args.o)))if(args.delete): os.remove(args.file) 测试1234$ python compress.py test_input.txt -o outputbefore compress: 887071 Bytesafter compress: 503056 Bytes","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"algorithm","slug":"algorithm","permalink":"http://yoursite.com/tags/algorithm/"}]}]}